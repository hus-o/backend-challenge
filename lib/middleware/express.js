import bodyParser from 'body-parser';
import rulesJson from "./rules.json"

export default function (app) {
  app.set('port', process.env.PORT || 3000);
  app.use(bodyParser.json());
  app.use(bodyParser.urlencoded({ extended: true }));
}

/**
 * TBD: middleware that checks the request body and querystring against the
 * existing json configuration in order to ensure that:
 * all required parameters are present
 * all parameters are of the correct type
 * non-existing parameters are blocked
 *
 * @throws throw a 400 code error with a relevant error message
 *
 * @param {object} req request object generated by express
 * @param {object} res response object generated by express
 * @param {function} next middleware function
 */

// These functions could be put together as they do very similar things but I kept it separate for ease of editing in future
// as they deal with separate concerns (query vs body), so I think it's cleaner looking like this.

const checkQueryParamsType = (reqParam, paramsArr) => {
  const badParams = []
  for (const [key, value] of Object.entries(reqParam)){
    const includedParam = paramsArr.find(item => item.name === key)
    const checkType = includedParam.type === "integer" ? "number" : includedParam.type
    const check = typeof value === checkType
    !check && badParams.push(includedParam)
  }

  if (badParams.length){
    const messageList = badParams.map((item )=> {
      return (
        item.type === "array" ?
        `${item.name} should be array of ${item.items.type}s`
        :
        `${item.name} should be of type ${item.type}`
    )})

    return {
      valid: false,
      message: messageList.join(",")
    }
  }
  return {
    valid: true,
    message: ""
  }
  
  // Didn't make sense to me to check types of non-string variables in a querySTRING,
  // I assume I'm missing something in my understanding
};

const checkBodyParamsType = (reqParams, paramsArr) => {
  const schemaProperties = Object.entries(paramsArr[0].schema.properties)
  const badParams = []

  for (const [key, value] of Object.entries(reqParams)){
    const includedParam = schemaProperties.find(item => item[0] === key)

    const checkType = includedParam[1].type === "integer" ? "number" : includedParam[1].type
    const check = typeof value === checkType
    !check && badParams.push(includedParam)
  }

  if (badParams.length){
    const messageList = badParams.map((item )=> {
      return (
        `${item[0]} should be of type ${item[1].type}`
    )})

    return {
      valid: false,
      message: messageList.join(",")
    }
  }

  return {
    valid: true,
    message: ""
  }
}

const checkQueryParamsExist = (reqParams, allowedParams) => {
  const reqKeys = Object.keys(reqParams)
  const rulesKeys = allowedParams.map(param => param.name)
  const validParams = reqKeys.every(val => rulesKeys.includes(val))

  if (!validParams){
    return {
      valid: false,
      message: `Invalid query parameter, please ensure only these parameters are used ${rulesKeys}`
    }
  }

  return {
    valid: true,
    message: ""
  }
}

const checkBodyParamsExist = (reqParams, allowedParams) => {
  const schemaProperties = allowedParams[0].schema.properties || []
  const isRequired = allowedParams[0].schema.required || []
  const reqKeys = Object.keys(reqParams)
  const rulesKeys = Object.keys(schemaProperties)
  const hasRequired = isRequired.every(val => reqKeys.includes(val))
  const validParams = reqKeys.every(val => rulesKeys.includes(val))

  if (!hasRequired){
    return {
      valid: false,
      message: `Missing required parameter(s) ${isRequired}`
    }
  }

  if (!validParams){
    return {
      valid: false,
      message: `Invalid body parameter, please ensure only these parameters are used ${rulesKeys}`
    }
  }

  return {
    valid: true,
    message: ""
  }
}

export const checkAgainstRules = (req, res, next) => {
  const pathname = req.baseUrl + req.path
  const body = req.body
  const method = req.method.toLowerCase()
  const query = req.query

  if (pathname in rulesJson.paths){
    const pathRules = rulesJson.paths[pathname][method]
    const hasParams = Object.keys(body).length && Object.keys(query).length

    if (!pathRules){
      return res.status(400).send({
        response: "Incorrect method"
      })
    }

    if (req.path !== "/role" && hasParams && !req.is('application/json')){
      return res.status(400).send({
        response: "Invalid Content-Type. Ensure it is application/json"
      })
    }
    
    if ("parameters" in pathRules){
      const params = pathRules["parameters"]
      const bodyParamRules = params.filter(param => param.in === "body")
      const queryParamRules = params.filter(param => param.in === "query")

      if (Object.keys(body).length !== 0 && bodyParamRules.length === 0){
        return res.status(400).send({
          response: "Body parameters not accepted for this endpoint"
        })
      }

      if (Object.keys(query).length !==0 && queryParamRules.length === 0){
        return res.status(400).send({
          response: "Query parameters not accepted for this endpoint"
        })
      }

      if (bodyParamRules.length !== 0){
        const bodyParamExistCheck = checkBodyParamsExist(body, bodyParamRules)
        
        if (!bodyParamExistCheck.valid){
          return res.status(400).send({
            response: bodyParamExistCheck.message
          })
        }

        const bodyParamTypeCheck = checkBodyParamsType(body, bodyParamRules)
        if (!bodyParamTypeCheck.valid){
          return res.status(400).send({
            response: bodyParamTypeCheck.message
          })
        }
      }

      if (queryParamRules.length !== 0){
        const queryParamExistCheck = checkQueryParamsExist(query, queryParamRules)
        
        if (!queryParamExistCheck.valid){
          return res.status(400).send({
            response: queryParamExistCheck.message
          })
        }

        const queryParamTypeCheck = checkQueryParamsType(query, queryParamRules)
        if(!queryParamTypeCheck.valid){
          return res.status(400).send({
            response: queryParamTypeCheck.message
          })
        }
      }
      } else {
          if (Object.keys(body).length || Object.keys(query).length){
            return res.status(400).send({
              response: "Parameter not found"
            })
          }
      }
    }
  return next();
};